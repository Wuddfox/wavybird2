<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Flappy Visualizer - Scaled</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100vw; height: 100vh;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #startBtn {
      position: absolute;
      top: 20px; left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      background: #0f0;
      border: none;
      border-radius: 5px;
      z-index: 10;
    }
    #score {
      position: absolute;
      top: 60px; left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 18px;
      z-index: 10;
    }
  </style>
</head>
<body>

<button id="startBtn">Start Game</button>
<div id="score">Score: 0 | High Score: 0</div>
<canvas id="gameCanvas"></canvas>
<audio id="bgMusic" crossorigin="anonymous"></audio>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const scoreDisplay = document.getElementById("score");
const music = document.getElementById("bgMusic");

let audioCtx, analyser, source, dataArray;
let bird, bars = [], score = 0, highScore = 0, gameRunning = false;
let startTime;
let flapLocked = false;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Dynamic sizes based on canvas
let FLAP, GRAVITY, GAP_HEIGHT, BAR_WIDTH, BAR_SPEED, BIRD_SIZE;

function recalculateConstants() {
  BIRD_SIZE = canvas.height * 0.075;
  FLAP = -canvas.height * 0.005;
  GRAVITY = canvas.height * 0.00015;
  GAP_HEIGHT = canvas.height * 0.4;
  BAR_WIDTH = canvas.width * 0.08;
  BAR_SPEED = canvas.width * 0.0025;
}

class Bird {
  constructor() {
    this.x = canvas.width * 0.2;
    this.y = canvas.height * 0.4;
    this.vel = 0;
    this.size = BIRD_SIZE;
  }
  update() {
    this.vel += GRAVITY;
    this.y += this.vel;
    if (this.y + this.size > canvas.height || this.y < 0) endGame();
  }
  draw() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }
  flap() {
    this.vel = FLAP;
  }
}

async function setupAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const resp = await fetch("music.mp3");
  const blob = await resp.blob();
  music.src = URL.createObjectURL(blob);
  await music.play();
  source = audioCtx.createMediaElementSource(music);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 32;
  source.connect(analyser);
  analyser.connect(audioCtx.destination);
  dataArray = new Uint8Array(analyser.frequencyBinCount);
}

function generateBars() {
  bars = [];
  for (let i = 0; i < canvas.width / BAR_WIDTH + 2; i++) {
    bars.push({ x: i * BAR_WIDTH + canvas.width, freqIndex: i % 16 });
  }
}

function drawBars() {
  analyser.getByteFrequencyData(dataArray);
  const centerY = canvas.height / 2;

  for (let bar of bars) {
    bar.x -= BAR_SPEED;
    const val = dataArray[bar.freqIndex] || 0;
    const flicker = (val / 255) * (canvas.height * 0.1);
    const gapY = centerY - GAP_HEIGHT / 2 + Math.sin(performance.now() / 1000 + bar.freqIndex) * 10;

    ctx.fillStyle = `rgb(${val}, ${255 - val}, 0)`;
    ctx.fillRect(bar.x, 0, BAR_WIDTH - 2, gapY + flicker);
    ctx.fillRect(bar.x, gapY + GAP_HEIGHT + flicker, BAR_WIDTH - 2, canvas.height - (gapY + GAP_HEIGHT + flicker));

    bar.gapY = gapY;
    bar.flicker = flicker;
  }

  if (bars.length && bars[0].x + BAR_WIDTH < 0) {
    bars.shift();
    const newX = bars[bars.length - 1].x + BAR_WIDTH;
    bars.push({ x: newX, freqIndex: Math.floor(Math.random() * 16) });
  }
}

function checkCollision() {
  for (let bar of bars) {
    const bx = bar.x;
    const bw = BAR_WIDTH - 2;
    const gapY = bar.gapY + bar.flicker;
    if (
      bird.x < bx + bw &&
      bird.x + bird.size > bx &&
      (bird.y < gapY || bird.y + bird.size > gapY + GAP_HEIGHT)
    ) {
      endGame();
      break;
    }
  }
}

function gameLoop() {
  if (!gameRunning) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBars();
  bird.update();
  bird.draw();
  checkCollision();
  const elapsed = (performance.now() - startTime) / 1000;
  const currentScore = Math.floor(elapsed / 2.5);
  if (currentScore > score) {
    score = currentScore;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem("flappyHigh", score.toString());
    }
  }
  scoreDisplay.innerText = `Score: ${score} | High Score: ${highScore}`;
  requestAnimationFrame(gameLoop);
}

function initGame() {
  resizeCanvas();
  recalculateConstants();
  bird = new Bird();
  score = 0;
  generateBars();
  try {
    const stored = localStorage.getItem("flappyHigh");
    highScore = stored ? parseInt(stored) : 0;
  } catch (e) {
    highScore = 0;
  }
  scoreDisplay.innerText = `Score: 0 | High Score: ${highScore}`;
  gameRunning = true;
  startTime = performance.now();
  gameLoop();
}

function endGame() {
  gameRunning = false;
  music.pause();
  startBtn.style.display = "block";
  alert("Game Over!\nScore: " + score);
}

canvas.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  if (gameRunning && !flapLocked) {
    bird.flap();
    flapLocked = true;
    setTimeout(() => flapLocked = false, 250);
  }
});

startBtn.addEventListener("click", async () => {
  startBtn.style.display = "none";
  try {
    if (!audioCtx) await setupAudio();
    else {
      music.currentTime = 0;
      await music.play();
    }
  } catch (err) {
    alert("Audio playback failed: " + err.message);
  }
  initGame();
});
</script>
</body>
</html>
